/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdio.h>
#include <SLES/OpenSLES.h>

#include <android/log.h>
#include <stdio.h>
#include <malloc.h>
#include <SLES/OpenSLES_Android.h>

#define LOG_TAG    "opensl-play"
#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

/* Header for class com_liuwei_audiodemo_OpenGLActivity */
static FILE *File = NULL;
#ifndef _Included_com_liuwei_audiodemo_OpenGLActivity
#define _Included_com_liuwei_audiodemo_OpenGLActivity
#ifdef __cplusplus
extern "C" {
#endif

static SLObjectItf engineSL = NULL;

SLEngineItf CreateSL() {
    //1 创建引擎对象
    SLresult re;
    SLEngineItf en; //存引擎接口
    re = slCreateEngine(&engineSL, 0, 0, 0, 0, 0);
    if (re != SL_RESULT_SUCCESS) return NULL;

    //2 实例化 SL_BOOLEAN_FALSE等待对象创建
    re = (*engineSL)->Realize(engineSL, SL_BOOLEAN_FALSE);
    if (re != SL_RESULT_SUCCESS) return NULL;

    //3 获取接口
    re = (*engineSL)->GetInterface(engineSL, SL_IID_ENGINE, &en);
    if (re != SL_RESULT_SUCCESS) return NULL;
    return en;
}

//回调函数
void pcmCallBack(SLAndroidSimpleBufferQueueItf bf, void *contex) {
    LOGI("pcmCallBack ");
    static char buf[1024 * 1024] = "";
    if (feof(File) == 0) { //没到结尾
        int len = (int) fread(&buf, 1, 1024, File);
        if (len > 0) {
            // 加入队列
            (*bf)->Enqueue(bf, &buf, len);
        }
    }
}

/*
 * Class:     com_liuwei_audiodemo_OpenGLActivity
 * Method:    play
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_liuwei_audiodemo_OpenSLActivity_play
        (JNIEnv *jniEnv, jobject instance, jstring path) {

    const char *file_path = (*jniEnv)->GetStringUTFChars(jniEnv, path, NULL);
    File = fopen(file_path, "rb");
    if (!File) {
        LOGE("file open failed");
        return -1;
    }
    (*jniEnv)->ReleaseStringUTFChars(jniEnv, path, file_path);

    //1 创建引擎
    SLEngineItf eng = CreateSL();
    if (eng) {
        LOGE("CreateSL success！ ");
    } else {
        LOGE("CreateSL failed！ ");
        return -1;
    }

    //2 创建混音器
    SLObjectItf mix = NULL;
    SLresult re = 0;

    re = (*eng)->CreateOutputMix(eng, &mix, 0, 0, 0);
    if (re != SL_RESULT_SUCCESS) {
        LOGE("SL_RESULT_SUCCESS failed!");
        return -1;
    }

    re = (*mix)->Realize(mix, SL_BOOLEAN_FALSE);
    if (re != SL_RESULT_SUCCESS) {
        LOGE("(*mix)->Realize failed!");
        return -1;
    }


    SLDataLocator_OutputMix outmix = {SL_DATALOCATOR_OUTPUTMIX, mix};
    SLDataSink audioSink = {&outmix, 0};

    //3 配置音频信息
    //数据定位器 就是定位要播放声音数据的存放位置，分为4种：内存位置，输入/输出设备位置，缓冲区队列位置，和midi缓冲区队列位置。
    SLDataLocator_AndroidSimpleBufferQueue que = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 10};
    //音频格式
    SLDataFormat_PCM pcm = {
            SL_DATAFORMAT_PCM,
            1,//    声道数
            SL_SAMPLINGRATE_44_1,
            SL_PCMSAMPLEFORMAT_FIXED_16,
            SL_PCMSAMPLEFORMAT_FIXED_16,
            SL_SPEAKER_FRONT_LEFT,
            SL_BYTEORDER_LITTLEENDIAN //字节序，小端
    };
    SLDataSource ds = {&que, &pcm};


    //4 创建播放器
    SLObjectItf player = NULL;
    SLPlayItf iplayer = NULL;
    SLAndroidSimpleBufferQueueItf pcmQue = NULL;
    const SLInterfaceID ids[] = {SL_IID_BUFFERQUEUE};
    const SLboolean req[] = {SL_BOOLEAN_TRUE};
    re = (*eng)->CreateAudioPlayer(eng, &player, &ds, &audioSink,
                                   sizeof(ids) / sizeof(SLInterfaceID), ids, req);
    if (re != SL_RESULT_SUCCESS) {
        LOGE("CreateAudioPlayer failed!");
    } else {
        LOGE("CreateAudioPlayer success!");
    }
    (*player)->Realize(player, SL_BOOLEAN_FALSE);
    //获取player接口
    re = (*player)->GetInterface(player, SL_IID_PLAY, &iplayer);
    if (re != SL_RESULT_SUCCESS) {
        LOGE("GetInterface SL_IID_PLAY failed!");
    }
    re = (*player)->GetInterface(player, SL_IID_BUFFERQUEUE, &pcmQue);
    if (re != SL_RESULT_SUCCESS) {
        LOGE("GetInterface SL_IID_BUFFERQUEUE failed!");
    }

    //设置回调函数，播放队列空调用
    (*pcmQue)->RegisterCallback(pcmQue, pcmCallBack, 0);

    //设置为播放状态
    (*iplayer)->SetPlayState(iplayer, SL_PLAYSTATE_PLAYING);

    //启动队列回调
    (*pcmQue)->Enqueue(pcmQue, "", 1);
    return 0;
}

/*
 * Class:     com_liuwei_audiodemo_OpenGLActivity
 * Method:    playStop
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_liuwei_audiodemo_OpenSLActivity_playStop
        (JNIEnv *jniEnv, jobject instance) {

    return 0;
}

#ifdef __cplusplus
}
#endif
#endif
